function print_number(n: int): int {
	asm {
		mov		eax, edi				; function arg
		mov		ecx, 0xa				; base 10
		push	rcx						; ASCII newline '\n' = 0xa = base
		mov		rsi, rsp
		sub		rsp, 16					; not needed on 64-bit Linux, the red-zone is big enough.  Change the LEA below if you remove this.
										; rsi is pointing at '\n' on the stack, with 16B of "allocated" space below that.
	.toascii_digit:						; do 
		xor		edx, edx
		div		ecx						; edx=remainder = low digit = 0..9.  eax/=10
										;; DIV IS SLOW.  use a multiplicative inverse if performance is relevant.
		add		edx, '0'
		dec		rsi						; store digits in MSD-first printing order, working backwards from the end of the string
		mov		[rsi], dl
		test	eax, eax				;  while(x);
		jnz		.toascii_digit
										; rsi points to the first digit
		mov		eax, 1					; __NR_write from /usr/include/asm/unistd_64.h
		mov		edi, 1					; fd = STDOUT_FILENO
		; pointer already in RSI		; buf = last digit stored = most significant
		lea		edx, [rsp + 16 + 1]		; yes, it's safe to truncate pointers before subtracting to find length.
		sub		edx, esi				; RDX = length = end-start, including the \n
		syscall							; write(1, string /*RSI*/,  digits + 1)

		add		rsp, 24					; (in 32-bit: add esp,20) undo the push and the buffer reservation
	}
	return 0;
}

function sqrt(n: int): int {
	if (n < 0)
		return -1;
	if (n == 0)
		return 0;

	var x: int = n;
	var y: int = 1;
	while (x > y) {
		x = (x + y) / 2;
		y = n / x;
	}
	return x;
}

function isPrime(n: long): bool {
	if (n <= 1)
		return false;

	var index: long = 2;
	var upperBound: long = sqrt(n) + 1;

	while(index < upperBound) {
		if (n % index == 0) {
			return false;
		}
		++index;
	}

	return true;
}

function main(): int {
	var index: long = 3;
	const upperBound: long = sqrt(600851475143) + 1;
	var biggestPrimeFactor: long = 0;

	while(index < upperBound) {
		if (600851475143 % index == 0) {
			if (isPrime(index)) {
				//print_number(index);
				biggestPrimeFactor = index;
			}
		}
		index += 2;
	}

	print_number(biggestPrimeFactor); // 6857

	return 0;
}