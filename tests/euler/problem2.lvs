function print_number(n: int): int {
	asm {
		mov		eax, edi				; function arg
		mov		ecx, 0xa				; base 10
		push	rcx						; ASCII newline '\n' = 0xa = base
		mov		rsi, rsp
		sub		rsp, 16					; not needed on 64-bit Linux, the red-zone is big enough.  Change the LEA below if you remove this.
										; rsi is pointing at '\n' on the stack, with 16B of "allocated" space below that.
	.toascii_digit:						; do 
		xor		edx, edx
		div		ecx						; edx=remainder = low digit = 0..9.  eax/=10
										;; DIV IS SLOW.  use a multiplicative inverse if performance is relevant.
		add		edx, '0'
		dec		rsi						; store digits in MSD-first printing order, working backwards from the end of the string
		mov		[rsi], dl
		test	eax, eax				;  while(x);
		jnz		.toascii_digit
										; rsi points to the first digit
		mov		eax, 1					; __NR_write from /usr/include/asm/unistd_64.h
		mov		edi, 1					; fd = STDOUT_FILENO
		; pointer already in RSI		; buf = last digit stored = most significant
		lea		edx, [rsp + 16 + 1]		; yes, it's safe to truncate pointers before subtracting to find length.
		sub		edx, esi				; RDX = length = end-start, including the \n
		syscall							; write(1, string /*RSI*/,  digits + 1)

		add		rsp, 24					; (in 32-bit: add esp,20) undo the push and the buffer reservation
	}
	return 0;
}

function fib(n: int): int {
	if (n <= 1)
		return 1;
	return fib(n-1) + fib(n-2);
}

function main(): int {
	var sum: int = 0;
	var index: int = 0;
	var current: int = 0;

	while (current < 4000000) {
		current = fib(++index);
		if (current % 2 == 0) {
			sum += current;
		}
	}

	print_number(sum);
	return 0;
}