{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Table of Contents Get Started Installation Compiler Language Reference Language Specifications License","title":"Home"},{"location":"#overview","text":"","title":"Overview"},{"location":"#table-of-contents","text":"Get Started Installation Compiler Language Reference Language Specifications License","title":"Table of Contents"},{"location":"compiler/","text":"Luvascript Compiler Luvascript Calling Convention (LCC) Compiler Messages","title":"Overview"},{"location":"compiler/#luvascript-compiler","text":"Luvascript Calling Convention (LCC) Compiler Messages","title":"Luvascript Compiler"},{"location":"compiler/calling_convention/","text":"Luvascript Calling Convention (LCC) Because of its implementation the luvascript language uses a different calling convention for functions and variables. Why not use the standard C calling convention ? In the Luvascript language you can use a function identifier multiple times, so you can use the same function name for different functions. This is not possible in the C language and therefore it is not in the C calling convention . Limitations You can use the same function name for different functions, but the parameter types of the functions must be different. Example function test(value: i32): bool { return value == 0; } function test(value: i64): bool { return value == 0; } In this case you can use the same function name for different functions, because the parameter types of value are different. function test(value: bool): bool { return value == false; } function test(value: bool): bool { return value == true; } In this case you cannot use the same function name for different functions, because the parameter types of value are the same. How to use the standard C calling convention If you want to use the standard C calling convention , you can use the extern keyword. extern function <identifier> ( <parameters> ): <return_type> { <body> } See also: External Functions Format General format: _func_<function_name>_<parameters>_<return_type> Example The name of this function function test(text: string, count: i64): bool { return text.length == count; } will be converted to _func_test_string_i64_bool","title":"Luvascript Calling Convention (LCC)"},{"location":"compiler/calling_convention/#luvascript-calling-convention-lcc","text":"Because of its implementation the luvascript language uses a different calling convention for functions and variables.","title":"Luvascript Calling Convention (LCC)"},{"location":"compiler/calling_convention/#why-not-use-the-standard-c-calling-convention","text":"In the Luvascript language you can use a function identifier multiple times, so you can use the same function name for different functions. This is not possible in the C language and therefore it is not in the C calling convention .","title":"Why not use the standard C calling convention?"},{"location":"compiler/calling_convention/#limitations","text":"You can use the same function name for different functions, but the parameter types of the functions must be different.","title":"Limitations"},{"location":"compiler/calling_convention/#example","text":"function test(value: i32): bool { return value == 0; } function test(value: i64): bool { return value == 0; } In this case you can use the same function name for different functions, because the parameter types of value are different. function test(value: bool): bool { return value == false; } function test(value: bool): bool { return value == true; } In this case you cannot use the same function name for different functions, because the parameter types of value are the same.","title":"Example"},{"location":"compiler/calling_convention/#how-to-use-the-standard-c-calling-convention","text":"If you want to use the standard C calling convention , you can use the extern keyword. extern function <identifier> ( <parameters> ): <return_type> { <body> } See also: External Functions","title":"How to use the standard C calling convention"},{"location":"compiler/calling_convention/#format","text":"General format: _func_<function_name>_<parameters>_<return_type>","title":"Format"},{"location":"compiler/calling_convention/#example_1","text":"The name of this function function test(text: string, count: i64): bool { return text.length == count; } will be converted to _func_test_string_i64_bool","title":"Example"},{"location":"compiler/options/","text":"Luva Compiler Options -o [filename] specify output filename (default=a.out) -S generate assembly code -c disable linking -shared generate shared library -static generate static library --modules:__,__,.. specify (global or local installed) modules to link --src-root [dir] specify source root directory -nostdlib disable standard library","title":"Luva Compiler Options"},{"location":"compiler/options/#luva-compiler-options","text":"-o [filename] specify output filename (default=a.out) -S generate assembly code -c disable linking -shared generate shared library -static generate static library --modules:__,__,.. specify (global or local installed) modules to link --src-root [dir] specify source root directory -nostdlib disable standard library","title":"Luva Compiler Options"},{"location":"compiler/messages/","text":"Luvascript Compiler Messages Warnings No warnings have been added yet. Errors Errors thrown by the lexer LV:0001 LV:0002 LV:0003 Errors thrown by the parser No errors have been added yet. Errors thrown by the generator No errors have been added yet. Other errors thrown by the compiler No errors have been added yet.","title":"Compiler Messages"},{"location":"compiler/messages/#luvascript-compiler-messages","text":"","title":"Luvascript Compiler Messages"},{"location":"compiler/messages/#warnings","text":"No warnings have been added yet.","title":"Warnings"},{"location":"compiler/messages/#errors","text":"","title":"Errors"},{"location":"compiler/messages/#errors-thrown-by-the-lexer","text":"LV:0001 LV:0002 LV:0003","title":"Errors thrown by the lexer"},{"location":"compiler/messages/#errors-thrown-by-the-parser","text":"No errors have been added yet.","title":"Errors thrown by the parser"},{"location":"compiler/messages/#errors-thrown-by-the-generator","text":"No errors have been added yet.","title":"Errors thrown by the generator"},{"location":"compiler/messages/#other-errors-thrown-by-the-compiler","text":"No errors have been added yet.","title":"Other errors thrown by the compiler"},{"location":"compiler/messages/errors/0x0001/","text":"Error 0x01 Example error message: unknown token '$'","title":"Error 0x01"},{"location":"compiler/messages/errors/0x0001/#error-0x01","text":"Example error message: unknown token '$'","title":"Error 0x01"},{"location":"compiler/messages/errors/0x0002/","text":"Error 0x02 Example error message: unexpected token '{'","title":"Error 0x02"},{"location":"compiler/messages/errors/0x0002/#error-0x02","text":"Example error message: unexpected token '{'","title":"Error 0x02"},{"location":"compiler/messages/errors/0x0003/","text":"Error 0x03 Example error message: invalid character literal '$?'","title":"Error 0x03"},{"location":"compiler/messages/errors/0x0003/#error-0x03","text":"Example error message: invalid character literal '$?'","title":"Error 0x03"},{"location":"compiler/messages/errors/0x0004/","text":"","title":"0x0004"},{"location":"compiler/messages/warnings/0x0001/","text":"","title":"0x0001"},{"location":"getting-started/","text":"Getting Started","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"installation/","text":"Installation","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/linux/","text":"","title":"Install on Linux"},{"location":"installation/macos/","text":"","title":"Install on MacOS"},{"location":"installation/windows/","text":"","title":"Install on Windows"},{"location":"language-reference/","text":"Luvascript Language Reference Order of Operations Datatypes External Functions Inline Assembly","title":"Overview"},{"location":"language-reference/#luvascript-language-reference","text":"Order of Operations Datatypes External Functions Inline Assembly","title":"Luvascript Language Reference"},{"location":"language-reference/datatypes/","text":"Luvascript Datatypes primitive datatypes Type Size i8 1 byte i16 2 bytes i32 4 bytes i64 8 bytes u8 1 byte u16 2 bytes u32 4 bytes u64 8 bytes f32 4 bytes f64 8 bytes bool 1 byte char 1 byte string 8 bytes (pointer) (actual size depends on length of the string)","title":"Datatypes"},{"location":"language-reference/datatypes/#luvascript-datatypes","text":"","title":"Luvascript Datatypes"},{"location":"language-reference/datatypes/#primitive-datatypes","text":"Type Size i8 1 byte i16 2 bytes i32 4 bytes i64 8 bytes u8 1 byte u16 2 bytes u32 4 bytes u64 8 bytes f32 4 bytes f64 8 bytes bool 1 byte char 1 byte string 8 bytes (pointer) (actual size depends on length of the string)","title":"primitive datatypes"},{"location":"language-reference/external_functions/","text":"External Functions Why should I use external functions The luvascript language does not follow the standard C calling convention when naming functions and variables. It instead uses a different calling convention called the Luvascript Calling Convention (LCC) . Therefore you have to specify the extern -keyword when you want to call the function from a different programming language. The the compiler knows that it should use the C calling convention instead of the LCC. Define a external function extern function <identifier> ( <parameters> ) : <return-type> Important You need to disable linking by the luvascript compiler when using external functions. Otherwise the compiler will try to link the object file to the executable, but the linker will not find a reference to the external function.","title":"External Functions"},{"location":"language-reference/external_functions/#external-functions","text":"","title":"External Functions"},{"location":"language-reference/external_functions/#why-should-i-use-external-functions","text":"The luvascript language does not follow the standard C calling convention when naming functions and variables. It instead uses a different calling convention called the Luvascript Calling Convention (LCC) . Therefore you have to specify the extern -keyword when you want to call the function from a different programming language. The the compiler knows that it should use the C calling convention instead of the LCC.","title":"Why should I use external functions"},{"location":"language-reference/external_functions/#define-a-external-function","text":"extern function <identifier> ( <parameters> ) : <return-type>","title":"Define a external function"},{"location":"language-reference/external_functions/#important","text":"You need to disable linking by the luvascript compiler when using external functions. Otherwise the compiler will try to link the object file to the executable, but the linker will not find a reference to the external function.","title":"Important"},{"location":"language-reference/inline_assembly/","text":"Inline Assembly in the Luva Language Limitations Currently the Luvascript compiler does only support inline assembly for x86-64 platforms. Additional information about x86-64 assembly is available in the x86 Assembly Guide . It is planned to support other platforms in the future. The inline assembly has to be in the Intel syntax. It is currently not possible to reference luvascript variables in the inline assembly. How to enable Inline Assembly is enabled by default and can not be disabled (yet). How to use Use the inline assembly syntax to write assembly code. asm { <assembly> } The following example shows how to use inline assembly: function main(): int { asm { mov eax, 6 add eax, 9 mov rdi, rax mov rax, 60 syscall } } This example adds 6 and 9 and uses the result as exit code.","title":"Inline Assembly in the Luva Language"},{"location":"language-reference/inline_assembly/#inline-assembly-in-the-luva-language","text":"","title":"Inline Assembly in the Luva Language"},{"location":"language-reference/inline_assembly/#limitations","text":"Currently the Luvascript compiler does only support inline assembly for x86-64 platforms. Additional information about x86-64 assembly is available in the x86 Assembly Guide . It is planned to support other platforms in the future. The inline assembly has to be in the Intel syntax. It is currently not possible to reference luvascript variables in the inline assembly.","title":"Limitations"},{"location":"language-reference/inline_assembly/#how-to-enable","text":"Inline Assembly is enabled by default and can not be disabled (yet).","title":"How to enable"},{"location":"language-reference/inline_assembly/#how-to-use","text":"Use the inline assembly syntax to write assembly code. asm { <assembly> } The following example shows how to use inline assembly: function main(): int { asm { mov eax, 6 add eax, 9 mov rdi, rax mov rax, 60 syscall } } This example adds 6 and 9 and uses the result as exit code.","title":"How to use"},{"location":"language-reference/order_of_opartions/","text":"Order of operations Precedence Operator Description Associativity 1 ++ -- Suffix/postfix increment and decrement left-to-right 2 ++ -- Prefix increment and decrement right-to-left 3 ** Power 4 * / % Multiplication, division, and remainder left-to-right 5 + - Addition and subtraction 6 < < >> Bitwise left shift and right shift 7 < < = > >= For relational operators < and \u2264 respectively For relational operators > and \u2265 respectively 8 == != For relational = and \u2260 respectively 9 & Bitwise AND 10 ^ Bitwise XOR (exclusive or) 11 | Bitwise OR (inclusive or) 12 && Logical AND 13 || Logical OR 14 ? : Ternary conditional right-to-left 15 = += -= *= /= %= < < = >>= &= ^= |= Simple assignment Assignment by sum and difference Assignment by product, quotient, and remainder Assignment by bitwise left shift and right shift Assignment by bitwise AND, XOR, and OR 16 , Comma left-to-right","title":"Order of operations"},{"location":"language-reference/order_of_opartions/#order-of-operations","text":"Precedence Operator Description Associativity 1 ++ -- Suffix/postfix increment and decrement left-to-right 2 ++ -- Prefix increment and decrement right-to-left 3 ** Power 4 * / % Multiplication, division, and remainder left-to-right 5 + - Addition and subtraction 6 < < >> Bitwise left shift and right shift 7 < < = > >= For relational operators < and \u2264 respectively For relational operators > and \u2265 respectively 8 == != For relational = and \u2260 respectively 9 & Bitwise AND 10 ^ Bitwise XOR (exclusive or) 11 | Bitwise OR (inclusive or) 12 && Logical AND 13 || Logical OR 14 ? : Ternary conditional right-to-left 15 = += -= *= /= %= < < = >>= &= ^= |= Simple assignment Assignment by sum and difference Assignment by product, quotient, and remainder Assignment by bitwise left shift and right shift Assignment by bitwise AND, XOR, and OR 16 , Comma left-to-right","title":"Order of operations"},{"location":"language-specifications/","text":"Luvascript Language Specification Version 0.1.0","title":"Overview"},{"location":"language-specifications/#luvascript-language-specification","text":"Version 0.1.0","title":"Luvascript Language Specification"},{"location":"language-specifications/v0.1.0/","text":"Version 0.1.0 Luvascript syntax in Backus Naur Form <program> ::= <function> | <program> <function> <function> ::= 'function' <identifier> '(' [<parameter>] ')' ':' [<function return types>] '{' [<statement list>] '}' <param declaration> ::= <identifier> [',' <param declaration>] | <identifier> ':' <type> [',' <param declaration>] | <identifier> ':' <type> '=' <expression> [',' <param declaration>] | <identifier> '=' <expression> [',' <param declaration>] <function return types> ::= [',' <function return types>] | ':' <type> [',' <function return types>] | ':' <type> '=' <expression> [',' <function return types>] | '=' <expression> [',' <function return types>] # ---------------- [ Statements ] ---------------- <statement list> ::= <statement> | <statement list> <statement> <statement> ::= <block statement> | <variable declaration> | <return statement> | <no-op statement> <block statement> ::= '{' <statement> '}' <variable declaration> ::= ('var' | 'const') <identifier> '=' <expression> (';' | ',' <variable declaration>) | ('var' | 'const') <identifier> ':' <type> (';' | ',' <variable declaration>) | ('var' | 'const') <identifier> ':' <type> '=' <expression> (';' | ',' <variable declaration>) <return statement> ::= 'return' <expression> ';' <no-op statement> ::= ';' $ignore # ---------------- [ Expressions ] ---------------- <expression> ::= <literal expression> | <indexing expression> | <function-call expression> | <binary expression> | <unary expression> | <ternary expression> <literal expression> ::= <identifier> | <string> | <number> <indexing expression> ::= <identifier> '[' <expression> ']' <function-call expression> ::= <identifier> '(' [<expression> [',' <expression>]* ]* ')' <binary expression> ::= <expression> <binary operator> <expression> <unary expression> ::= <unary operator> <expression> <assignment expression> ::= <identifier> <assignment operator> <expression> <conditional expression>::= <expression> <conditional operator> <expression> <ternary expression> ::= <conditional expression> '?' <expression> ':' <expression> # ---------------- [ Types ] ---------------- <type> ::= <primitive type> <primitive type> ::= 'byte' | 'short' | 'int' | 'long' | 'ubyte' | 'ushort' | 'uint' | 'ulong' | 'float' | 'double' | 'decimal' | 'char' | 'string' | 'bool' | 'void' # ---------------- [ Operator ] ---------------- <binary operator> ::= '+' | '-' | '*' | '/' | '%' | '**' | '<<' | '>>' <unary operator> ::= '+' | '-' | '!' | '++' | '--' <assignment operator> ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '^=' | '|=' <conditional operator> ::= '==' | '!=' | '<' | '>' | '<=' | '>=' | '&' | '^' | '|' | '&&' | '||' # ---------------- [ Other Stuff ] ---------------- <identifier> ::= [_a-zA-Z]* [a-zA-Z]+ <string> ::= '\"' ('\\.')* '\"' <number> ::= [0-9]+ <whitespace> ::= ' ' | '\\t' | '\\r' | '\\n' $ignore","title":"Version 0.1.0"},{"location":"language-specifications/v0.1.0/#version-010","text":"Luvascript syntax in Backus Naur Form <program> ::= <function> | <program> <function> <function> ::= 'function' <identifier> '(' [<parameter>] ')' ':' [<function return types>] '{' [<statement list>] '}' <param declaration> ::= <identifier> [',' <param declaration>] | <identifier> ':' <type> [',' <param declaration>] | <identifier> ':' <type> '=' <expression> [',' <param declaration>] | <identifier> '=' <expression> [',' <param declaration>] <function return types> ::= [',' <function return types>] | ':' <type> [',' <function return types>] | ':' <type> '=' <expression> [',' <function return types>] | '=' <expression> [',' <function return types>] # ---------------- [ Statements ] ---------------- <statement list> ::= <statement> | <statement list> <statement> <statement> ::= <block statement> | <variable declaration> | <return statement> | <no-op statement> <block statement> ::= '{' <statement> '}' <variable declaration> ::= ('var' | 'const') <identifier> '=' <expression> (';' | ',' <variable declaration>) | ('var' | 'const') <identifier> ':' <type> (';' | ',' <variable declaration>) | ('var' | 'const') <identifier> ':' <type> '=' <expression> (';' | ',' <variable declaration>) <return statement> ::= 'return' <expression> ';' <no-op statement> ::= ';' $ignore # ---------------- [ Expressions ] ---------------- <expression> ::= <literal expression> | <indexing expression> | <function-call expression> | <binary expression> | <unary expression> | <ternary expression> <literal expression> ::= <identifier> | <string> | <number> <indexing expression> ::= <identifier> '[' <expression> ']' <function-call expression> ::= <identifier> '(' [<expression> [',' <expression>]* ]* ')' <binary expression> ::= <expression> <binary operator> <expression> <unary expression> ::= <unary operator> <expression> <assignment expression> ::= <identifier> <assignment operator> <expression> <conditional expression>::= <expression> <conditional operator> <expression> <ternary expression> ::= <conditional expression> '?' <expression> ':' <expression> # ---------------- [ Types ] ---------------- <type> ::= <primitive type> <primitive type> ::= 'byte' | 'short' | 'int' | 'long' | 'ubyte' | 'ushort' | 'uint' | 'ulong' | 'float' | 'double' | 'decimal' | 'char' | 'string' | 'bool' | 'void' # ---------------- [ Operator ] ---------------- <binary operator> ::= '+' | '-' | '*' | '/' | '%' | '**' | '<<' | '>>' <unary operator> ::= '+' | '-' | '!' | '++' | '--' <assignment operator> ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '^=' | '|=' <conditional operator> ::= '==' | '!=' | '<' | '>' | '<=' | '>=' | '&' | '^' | '|' | '&&' | '||' # ---------------- [ Other Stuff ] ---------------- <identifier> ::= [_a-zA-Z]* [a-zA-Z]+ <string> ::= '\"' ('\\.')* '\"' <number> ::= [0-9]+ <whitespace> ::= ' ' | '\\t' | '\\r' | '\\n' $ignore","title":"Version 0.1.0"}]}